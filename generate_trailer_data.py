import pika
import json
from faker import Faker
import random
from datetime import datetime, timedelta
import sys
import time
from util_logger import setup_logger

# Configure logging
logger, logname = setup_logger(__file__)

fake = Faker()

# Generate fake trailer data
def generate_trailer_data():
    trailer_id = fake.unique.random_int(min=1000, max=9999)
    location = fake.city()
    status = random.choice(['arriving', 'arrived', 'departed', 'in transit'])
    temperature = round(random.uniform(-10, 30), 2)  # Random temperature between -10 to 30 degrees Celsius

    arrival_timestamp = None
    departure_timestamp = None

    if status == 'arriving' or status == 'arrived' or status == 'departed':
        arrival_timestamp = fake.date_time_between(start_date='-2d', end_date='now').isoformat()
    
    if status == 'arrived' and datetime.fromisoformat(arrival_timestamp) < datetime.now() - timedelta(hours=24):
        status = 'idle'
    
    if status == 'departed':
        departure_timestamp = fake.date_time_between(start_date=datetime.fromisoformat(arrival_timestamp), end_date='now').isoformat()

    trailer_data = {
        "trailer_id": trailer_id,
        "location": location,
        "status": status,
        "arrival_timestamp": arrival_timestamp,
        "departure_timestamp": departure_timestamp,
        "temperature": temperature
    }
    return trailer_data

def setup_rabbitmq_channel():
    connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))
    channel = connection.channel()
    
    # Delete existing queues with the same names
    queues = ['arriving_queue', 'arrived_queue', 'departed_queue', 'in_transit_queue', 'idle_queue']
    # for queue in queues:
    #     try:
    #         channel.queue_delete(queue=queue)
    #         logger.info("Queues deleted ")
    #     except pika.exceptions.ChannelError as e:
    #         print(f"Queue deletion error: {e}")
    #         logger.error(f"Queue deletion error: {e}")

    # Declare queues for each status with consistent settings
    for queue in queues:
        channel.queue_declare(queue=queue, durable=True)
    
    return connection, channel

def send_to_rabbitmq(channel, trailer_data):
    try:
        # Determine the routing key based on status
        status_to_queue = {
            'arriving': 'arriving_queue',
            'arrived': 'arrived_queue',
            'departed': 'departed_queue',
            'in transit': 'in_transit_queue',
            'idle': 'idle_queue'
        }
        routing_key = status_to_queue[trailer_data['status']]

        # Convert trailer_data dictionary to JSON string
        json_data = json.dumps(trailer_data)
        
        # Send JSON data to the appropriate queue
        channel.basic_publish(
            exchange='',
            routing_key=routing_key,
            body=json_data,
            properties=pika.BasicProperties(
                delivery_mode=pika.spec.PERSISTENT_DELIVERY_MODE,
            ))
        print(f" [x] Sent {json_data} to {routing_key}")
        logger.info(f"JSON data :{json_data} sent to Queue: {routing_key} ") 

    except pika.exceptions.AMQPConnectionError as e:
        print(f"Connection error: {e}")
        logger.error(f"Connection error: {e}")
    except pika.exceptions.ChannelError as e:
        print(f"Channel error: {e}")
        logger.error(f"Channel error: {e}")
    except json.JSONDecodeError as e:
        print(f"JSON decoding error: {e}")
        logger.error(f"JSON decoding error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")
        logger.error(f"Unexpected error: {e}")

# Main function to generate and send trailer data
def main():
    if len(sys.argv) < 2:
        print("Usage: python script_name.py <number_of_trailers>")
        logger.error("User didn't enter number_of_trailers while executing the script .Hence exiting .")
        sys.exit(1)

    num_trailers = int(sys.argv[1])
    logger.info(f"Data generated for number_of_trailers entered : {num_trailers}")


    # Setup RabbitMQ channel
    connection, channel = setup_rabbitmq_channel()

    try:
        for _ in range(num_trailers):
            trailer_data = generate_trailer_data()
            logger.info(f"Data generated by Faker : {trailer_data}")
            send_to_rabbitmq(channel, trailer_data)
            time.sleep(5)  # Wait for 5 seconds before sending the next message
    finally:
        # Ensure the connection is closed
        try:
            connection.close()
        except Exception as e:
            print(f"Error closing connection: {e}")

if __name__ == "__main__":
    main()
